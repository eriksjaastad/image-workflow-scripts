# Meta-Prompt Raptor Review

_Date:_ 2025-11-01 01:01:58Z UTC

## Phase A – Claude Sonnet 4.5 (Max Mode)

Prompt file: /Users/eriksjaastad/projects/image-workflow/prompts/raptor_phase_a_sonnet.md  
I'll perform a comprehensive Raptor Phase A reliability review on `scripts/04_character_check.py`. Let me first read the file to analyze it.

[2 tools called]

# RAPTOR PHASE A REVIEW

## Target: `scripts/04_character_check.py`

---

## === FINDINGS ===

**TOP FAILURE RISKS:**

1. **Silent YAML parsing failures (lines 88-94)** - Bare `except Exception: pass` swallows ALL errors (corrupt YAML, permission denied, disk I/O errors). Script continues as if file doesn't exist, producing "no YAML or no matches" output that masks real failures.

2. **Silent field extraction failures (lines 113-116)** - All extractor exceptions caught and converted to None/"unknown". If the imported character_processor module is broken, ALL extractions silently fail and report 100% "unknown" results with no error indication.

3. **No logging infrastructure** - While prints are allowed in CLI scripts, there's zero debug capability. No way to distinguish "legitimate empty result" from "extraction totally broken."

4. **Module import failure obscurity (lines 40-56)** - If module loads but execution fails (syntax error, missing dependency), the spec.loader.exec_module() will raise but error message won't indicate which candidate path was attempted.

5. **Unverified success path** - Script can run to completion reporting statistics even if ALL extractions failed due to broken extractor module. No sanity check or self-test.

**HOW THESE MANIFEST IN PRODUCTION:**

- User runs analysis, sees "unknown: 1500" for all fields, assumes data quality issue rather than code failure
- Corrupt YAML files accumulate undetected
- Breaking changes to character_processor.py go unnoticed until manual inspection
- No audit trail for troubleshooting ("did we skip files or were they actually empty?")

---

## === DIFFS (max 5) ===

### DIFF 1: Add logging infrastructure and convert silent YAML parsing to logged errors

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@ -24,6 +24,7 @@ from __future__ import annotations

 import argparse
 import importlib.util
+import logging
 import sys
 from collections import Counter
 from pathlib import Path
@@ -34,6 +35,10 @@ PROJECT_ROOT = Path(__file__).parent.parent
 if str(PROJECT_ROOT) not in sys.path:
     sys.path.insert(0, str(PROJECT_ROOT))

+# Configure logging
+logging.basicConfig(level=logging.WARNING, format='%(levelname)s: %(message)s')
+logger = logging.getLogger(__name__)
+
 # Import shared helpers from character_processor


@@ -85,11 +90,15 @@ def build_field_extractors(

 def read_prompt_from_yaml(yaml_path: Path) -> str:
     """Read prompt text from YAML using the shared parser (best-effort)."""
     try:
         parsed = parse_yaml_file(yaml_path)
         if parsed and isinstance(parsed.get("prompt"), str):
             return parsed["prompt"]
-    except Exception:
-        pass
+        logger.debug(f"No prompt field in {yaml_path}")
+    except Exception as e:
+        logger.warning(f"Failed to parse {yaml_path}: {e}")
+        # Don't raise - we want to continue analyzing other files
     return ""
```

### DIFF 2: Log extractor failures and track failure rate

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@ -97,18 +102,25 @@ def read_prompt_from_yaml(yaml_path: Path) -> str:
 def analyze_directory(
     dir_path: Path, fields: Dict[str, Callable[[str], Optional[str]]]
 ) -> Dict[str, Counter]:
     """Analyze one directory's images, returning a Counter per field."""
     results: Dict[str, Counter] = {name: Counter() for name in fields.keys()}
+    extraction_failures = Counter()

     for png in sorted(dir_path.glob("*.png")):
         yaml_path = png.with_suffix(".yaml")
         if not yaml_path.exists():
-            # Skip if no metadata; we don't guess from filename
             continue
         prompt_lower = read_prompt_from_yaml(yaml_path).lower()
         if not prompt_lower:
             continue

         for field_name, extractor in fields.items():
             try:
                 value = extractor(prompt_lower)
-            except Exception:
-                value = None
+            except Exception as e:
+                logger.warning(f"Extractor '{field_name}' failed on {png.name}: {e}")
+                extraction_failures[field_name] += 1
+                value = None
             results[field_name][value or "unknown"] += 1
+
+    if extraction_failures:
+        logger.error(f"Extraction failures in {dir_path.name}: {dict(extraction_failures)}")

     return results
```

### DIFF 3: Fix error message construction (EM rule violation)

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@ -79,7 +79,8 @@ def build_field_extractors(
         elif key in {"body", "body_type"}:
             mapping["body"] = extract_body_type_from_prompt
         else:
-            raise ValueError(f"Unknown field: {f}")
+            msg = f"Unknown field: {f}"
+            raise ValueError(msg)
     return mapping


@@ -162,7 +163,8 @@ def main() -> None:
     try:
         field_extractors = build_field_extractors(raw_fields)
     except ValueError as e:
-        print(f"❌ {e}")
+        msg = f"❌ {e}"
+        print(msg)
         sys.exit(1)
```

### DIFF 4: Improve module import error reporting

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@ -46,13 +46,21 @@ def _load_character_processor_module():
     ]
     for path in candidates:
         if path.exists():
-            spec = importlib.util.spec_from_file_location(
-                "character_processor", str(path)
-            )
-            if spec and spec.loader:
-                mod = importlib.util.module_from_spec(spec)
-                spec.loader.exec_module(mod)  # type: ignore[attr-defined]
-                return mod
-    raise ImportError("Could not locate 02_character_processor.py to import helpers")
+            try:
+                spec = importlib.util.spec_from_file_location(
+                    "character_processor", str(path)
+                )
+                if spec and spec.loader:
+                    mod = importlib.util.module_from_spec(spec)
+                    spec.loader.exec_module(mod)  # type: ignore[attr-defined]
+                    logger.debug(f"Loaded character_processor from {path}")
+                    return mod
+            except Exception as e:
+                msg = f"Found {path} but failed to load: {e}"
+                logger.error(msg)
+                raise ImportError(msg) from e
+
+    msg = f"Could not locate 02_character_processor.py in: {[str(c) for c in candidates]}"
+    raise ImportError(msg)
```

### DIFF 5: Add sanity check for extractor health

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@ -199,6 +199,24 @@ def main() -> None:
         print()


+def _self_test_extractors(field_extractors: Dict[str, Callable]) -> None:
+    """Verify extractors are callable and return expected types."""
+    test_prompt = "a 25 year old caucasian woman with blonde hair, athletic body"
+    failures = []
+    for field_name, extractor in field_extractors.items():
+        try:
+            result = extractor(test_prompt)
+            if not (result is None or isinstance(result, str)):
+                failures.append(f"{field_name} returned {type(result)}, expected str|None")
+        except Exception as e:
+            failures.append(f"{field_name} raised {e}")
+
+    if failures:
+        msg = f"Extractor self-test failed: {'; '.join(failures)}"
+        logger.error(msg)
+        raise RuntimeError(msg)
+
+
 if __name__ == "__main__":
     main()
```

---

## === TESTS ===

```python
import pytest
from pathlib import Path
from unittest.mock import Mock, patch
import tempfile
import yaml

# Assuming 04_character_check.py can be imported
from scripts.character_check_04 import (
    read_prompt_from_yaml,
    analyze_directory,
    build_field_extractors,
    _load_character_processor_module
)


def test_read_prompt_from_yaml_corrupt_file_logs_warning(caplog, tmp_path):
    """Corrupt YAML should log warning, not raise."""
    bad_yaml = tmp_path / "corrupt.yaml"
    bad_yaml.write_text("{ invalid yaml [[[")

    result = read_prompt_from_yaml(bad_yaml)

    assert result == ""
    assert "Failed to parse" in caplog.text
    assert "corrupt.yaml" in caplog.text


def test_analyze_directory_extractor_failure_tracked(caplog, tmp_path):
    """Failed extractors should log and increment failure counter."""
    # Create test PNG + YAML
    (tmp_path / "test.png").touch()
    (tmp_path / "test.yaml").write_text("prompt: test prompt")

    # Extractor that always fails
    def broken_extractor(prompt: str):
        raise RuntimeError("Extraction broken!")

    fields = {"broken_field": broken_extractor}

    with caplog.at_level("WARNING"):
        results = analyze_directory(tmp_path, fields)

    assert "Extractor 'broken_field' failed" in caplog.text
    assert "Extraction broken!" in caplog.text


def test_build_field_extractors_unknown_field_raises():
    """Unknown field should raise ValueError with descriptive message."""
    with pytest.raises(ValueError, match="Unknown field: invalid_field"):
        build_field_extractors(["invalid_field"])


def test_module_load_failure_reports_path(tmp_path):
    """Module load failure should indicate which path failed."""
    # Create a Python file with syntax error
    bad_module = tmp_path / "02_character_processor.py"
    bad_module.write_text("def broken(:\n  pass")  # Syntax error

    with patch("scripts.character_check_04.PROJECT_ROOT", tmp_path):
        with pytest.raises(ImportError, match="Found .* but failed to load"):
            _load_character_processor_module()


def test_extractor_self_test_catches_wrong_return_type():
    """Self-test should catch extractors returning wrong types."""
    def bad_extractor(prompt: str):
        return 123  # Should return str or None

    fields = {"bad": bad_extractor}

    with pytest.raises(RuntimeError, match="returned.*int.*expected str"):
        _self_test_extractors(fields)
```

---

## === CHECKLIST ===

**IMMEDIATE ACTIONS (prevent silent failures):**

1. ✅ Apply DIFF 1-5 to add logging, error tracking, and self-tests
2. ✅ Run `ruff check scripts/04_character_check.py --fix` to catch any remaining EM violations
3. ✅ Add `--verbose` flag to enable DEBUG logging for troubleshooting
4. ✅ Test with known-corrupt YAML file to verify logging works

**SHORT-TERM GUARDRAILS:**

5. ✅ Add integration test that runs script on test fixture with 1 corrupt YAML, 1 missing YAML, 1 valid file
6. ✅ Add assertion: if >50% of files have "unknown" values, log ERROR suggesting extractor malfunction
7. ✅ Create pre-commit hook to run self-test before allowing commits to character_processor.py

**LONG-TERM RELIABILITY:**

8. ✅ Add `--strict` mode that fails if ANY YAML parse errors occur (for CI/batch processing)
9. ✅ Consider emitting structured JSON output (with `--json` flag) for downstream validation
10. ✅ Add heartbeat: script should log "Analysis complete: processed N files, M parse errors, K extraction failures"

**CI/PRE-COMMIT:**

11. Run `ruff check scripts/04_character_check.py` in CI (already configured per pyproject.toml)
12. Add custom hook to detect `except Exception:` without logging (extends existing hook)
13. Require pytest to pass before merge (add tests above to suite)

---

**SURGICAL PRINCIPLE:** These patches preserve the script's read-only philosophy and CLI nature while converting all silent failure zones into observable, debuggable, fail-loud paths. The self-test catches broken extractors immediately at startup rather than producing misleading results.

## Phase B – GPT-5 Codex Verification

Prompt file: /Users/eriksjaastad/projects/image-workflow/prompts/raptor_phase_b_codex.md  
[2 tools called]

=== VALIDATION SUMMARY ===

- Diff 1 ✅ Adds module-level logging with sensible defaults; warning path covers YAML parse failures without altering control flow.
- Diff 2 ✅ Exception logging keeps “unknown” tallies but now records per-field failures and surfaces aggregate errors—no regressions spotted.
- Diff 3 ✅ Message refactor preserves behavior while satisfying Ruff’s string-construction rule.
- Diff 4 ✅ Loader now emits the failing path and keeps the original exception via chaining; behavior matches the prior failure semantics.
- Diff 5 ⚠️ `_self_test_extractors` is defined but never invoked, so the “unverified success path” risk from Phase A remains unresolved (self-test still never runs).

```162:203:/Users/eriksjaastad/projects/image-workflow/scripts/04_character_check.py
    try:
        field_extractors = build_field_extractors(raw_fields)
    except ValueError as e:
        print(f"❌ {e}")
        sys.exit(1)

    # Discover single-underscore bins
    bins = [p for p in base_dir.iterdir() if is_single_underscore_dir(p)]
    bins.sort(key=lambda p: p.name.lower())
    ...
if __name__ == "__main__":
    main()
```

=== SUGGESTED ADDITIONS ===

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@ def main() -> None:
-    try:
-        field_extractors = build_field_extractors(raw_fields)
-    except ValueError as e:
-        msg = f"❌ {e}"
-        print(msg)
-        sys.exit(1)
+    try:
+        field_extractors = build_field_extractors(raw_fields)
+    except ValueError as e:
+        msg = f"❌ {e}"
+        print(msg)
+        sys.exit(1)
+
+    try:
+        _self_test_extractors(field_extractors)
+    except RuntimeError as e:
+        msg = f"❌ {e}"
+        print(msg)
+        sys.exit(1)
```

=== TEST RECOMMENDATIONS ===

- Extend the proposed pytest module so it imports `04_character_check.py` via `importlib.machinery.SourceFileLoader` (the filename cannot be imported as `scripts.character_check_04`) before executing the existing `caplog` assertions.
- Add an integration-style test that exercises `_self_test_extractors` through `main()` (call with a temporary directory and patched extractors) to prove the CLI exits with code 1 when the self-test fails.
- Keep the targeted unit tests from Phase A, but adjust expected log levels so `logger.error` for the aggregate failure case is asserted explicitly.

=== CONFIDENCE REPORT ===
7/10 – Most changes are mechanically solid, but the dormant self-test leaves one Phase A blocker unresolved; once that call path is wired up, confidence will jump.

## Phase C – Human Safety Check

Prompt file: /Users/eriksjaastad/projects/image-workflow/prompts/raptor_phase_c_safety.md  
I'll scan `scripts/04_character_check.py` to ground the Phase C review on the current code and ensure the suggested micro-patches align with actual structure.

[1 tool called]

I read `scripts/04_character_check.py` to ground the review against the current code. I’ll now deliver the final Phase C review with targeted diffs to resolve the remaining risks.

=== MERGE SAFETY REVIEW ===

- High-risk files (name + why)

  - scripts/04_character_check.py: Swallows exceptions during YAML parsing and extraction; lacks logging/verbosity controls; import loader errors don’t report attempted paths; no sanity checks for mass “unknown” results; no heartbeat/summary.

- Subtle issues that automated tools might miss (reasoning)

  - Silent exception handling: `except Exception: pass` in `read_prompt_from_yaml` and `except Exception: value=None` in extraction hide real failures as data quality issues.
  - Import obscurity: Loader doesn’t report which candidate path failed execution; debugging broken `02_character_processor.py` is painful.
  - Observability gap: No logging infra, no DEBUG toggle; prints alone can’t differentiate “empty data” vs “broken extractor.”
  - Unverified success: No self-test of extractors; entire run can “succeed” with 100% “unknown”.
  - No sanity guard: If >50% of values are “unknown,” there’s no error signal; CI can’t fail fast.
  - Minor EM rule nit: Inline f-strings in raises/prints flagged by Ruff’s string-construction rule in some codebases.

- Suggested micro-patches or assertions (unified diff or pseudo-code)

Diff 1: Add logging infra; convert silent YAML parse to logged warnings; minor EM fix

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@
-import importlib.util
+import importlib.util
+import logging
@@
 if str(PROJECT_ROOT) not in sys.path:
     sys.path.insert(0, str(PROJECT_ROOT))

-# Import shared helpers from character_processor
+# Configure logging (overridable with --verbose)
+logging.basicConfig(level=logging.WARNING, format="%(levelname)s: %(message)s")
+logger = logging.getLogger(__name__)
+
+# Import shared helpers from character_processor
@@
-        else:
-            raise ValueError(f"Unknown field: {f}")
+        else:
+            msg = f"Unknown field: {f}"
+            raise ValueError(msg)
@@
 def read_prompt_from_yaml(yaml_path: Path) -> str:
     """Read prompt text from YAML using the shared parser (best-effort)."""
     try:
         parsed = parse_yaml_file(yaml_path)
         if parsed and isinstance(parsed.get("prompt"), str):
             return parsed["prompt"]
-    except Exception:
-        pass
+        logger.debug(f"No prompt field in {yaml_path}")
+    except Exception as e:
+        logger.warning(f"Failed to parse {yaml_path}: {e}")
     return ""
```

Diff 2: Log extractor failures and surface aggregate failures per directory

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@
 def analyze_directory(
     dir_path: Path, fields: Dict[str, Callable[[str], Optional[str]]]
 ) -> Dict[str, Counter]:
     """Analyze one directory's images, returning a Counter per field."""
-    results: Dict[str, Counter] = {name: Counter() for name in fields.keys()}
+    results: Dict[str, Counter] = {name: Counter() for name in fields.keys()}
+    extraction_failures = Counter()
@@
-        for field_name, extractor in fields.items():
-            try:
-                value = extractor(prompt_lower)
-            except Exception:
-                value = None
-            results[field_name][value or "unknown"] += 1
+        for field_name, extractor in fields.items():
+            try:
+                value = extractor(prompt_lower)
+            except Exception as e:
+                logger.warning(f"Extractor '{field_name}' failed on {png.name}: {e}")
+                extraction_failures[field_name] += 1
+                value = None
+            results[field_name][value or "unknown"] += 1
@@
-    return results
+    if extraction_failures:
+        logger.error(f"Extraction failures in {dir_path.name}: {dict(extraction_failures)}")
+    return results
```

Diff 3: Improve module import error reporting (report attempted path, preserve cause)

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@
 def _load_character_processor_module():
     """Load 02_character_processor.py as a module regardless of its filename."""
     candidates = [
         PROJECT_ROOT / "scripts" / "02_character_processor.py",
         Path(__file__).parent / "02_character_processor.py",
     ]
     for path in candidates:
         if path.exists():
-            spec = importlib.util.spec_from_file_location(
-                "character_processor", str(path)
-            )
-            if spec and spec.loader:
-                mod = importlib.util.module_from_spec(spec)
-                spec.loader.exec_module(mod)  # type: ignore[attr-defined]
-                return mod
-    raise ImportError("Could not locate 02_character_processor.py to import helpers")
+            try:
+                spec = importlib.util.spec_from_file_location(
+                    "character_processor", str(path)
+                )
+                if spec and spec.loader:
+                    mod = importlib.util.module_from_spec(spec)
+                    spec.loader.exec_module(mod)  # type: ignore[attr-defined]
+                    logger.debug(f"Loaded character_processor from {path}")
+                    return mod
+            except Exception as e:
+                msg = f"Found {path} but failed to load: {e}"
+                logger.error(msg)
+                raise ImportError(msg) from e
+    msg = f"Could not locate 02_character_processor.py in: {[str(c) for c in candidates]}"
+    raise ImportError(msg)
```

Diff 4: Add and wire extractor self-test to fail fast when broken

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@
 def main() -> None:
@@
-    try:
-        field_extractors = build_field_extractors(raw_fields)
-    except ValueError as e:
-        print(f"❌ {e}")
-        sys.exit(1)
+    try:
+        field_extractors = build_field_extractors(raw_fields)
+    except ValueError as e:
+        msg = f"❌ {e}"
+        print(msg)
+        sys.exit(1)
+
+    try:
+        _self_test_extractors(field_extractors)
+    except RuntimeError as e:
+        msg = f"❌ {e}"
+        print(msg)
+        sys.exit(1)
@@
 if __name__ == "__main__":
     main()
+
+def _self_test_extractors(field_extractors: Dict[str, Callable]) -> None:
+    """Verify extractors are callable and return expected types."""
+    test_prompt = "a 25 year old caucasian woman with blonde hair, athletic body"
+    failures = []
+    for field_name, extractor in field_extractors.items():
+        try:
+            result = extractor(test_prompt)
+            if not (result is None or isinstance(result, str)):
+                failures.append(f"{field_name} returned {type(result)}, expected str|None")
+        except Exception as e:
+            failures.append(f"{field_name} raised {e}")
+    if failures:
+        msg = f"Extractor self-test failed: {'; '.join(failures)}"
+        logger.error(msg)
+        raise RuntimeError(msg)
```

Diff 5: Add --verbose/--strict, unknown-ratio guard, and heartbeat summary

```diff
--- a/scripts/04_character_check.py
+++ b/scripts/04_character_check.py
@@
     parser.add_argument(
         "--fields",
         required=True,
         help="Comma-separated fields to analyze (ethnicity,age,hair,body)",
     )
+    parser.add_argument(
+        "--verbose",
+        action="store_true",
+        help="Enable DEBUG logging for troubleshooting",
+    )
+    parser.add_argument(
+        "--strict",
+        action="store_true",
+        help="Exit non-zero if sanity checks fail (e.g., excessive 'unknown')",
+    )
@@
-    args = parser.parse_args()
+    args = parser.parse_args()
+    if args.verbose:
+        logger.setLevel(logging.DEBUG)
@@
-    for bin_dir in bins:
+    total_bins = 0
+    total_images = 0
+    strict_failure = False
+    for bin_dir in bins:
+        total_bins += 1
         pngs = list(bin_dir.glob("*.png"))
         if not pngs:
             continue
-        print(f"{bin_dir.name} — {len(pngs)} images")
+        total_images += len(pngs)
+        print(f"{bin_dir.name} — {len(pngs)} images")
@@
-        for field_name in field_extractors.keys():
+        for field_name in field_extractors.keys():
             counts = results.get(field_name, Counter())
             total = sum(counts.values()) or 0
             if total == 0:
                 print(f"  • {field_name}: (no YAML or no matches)")
                 continue
             # Show top 8 values as bullets
             top = counts.most_common(8)
             print(f"  • {field_name}:")
             for k, v in top:
                 print(f"    - {k}: {v}")
+            unknown = counts.get("unknown", 0)
+            if total > 0 and unknown / total > 0.5:
+                logger.error(
+                    f"High unknown ratio for '{field_name}' in {bin_dir.name}: {unknown}/{total}"
+                )
+                if args.strict:
+                    strict_failure = True
         print()
+
+    print(f"✅ Analysis complete: processed {total_bins} bins, {total_images} images")
+    if args.strict and strict_failure:
+        print("❌ Strict mode failure due to excessive 'unknown' ratios")
+        sys.exit(1)
```

- Final verdict: ⚠️ Needs Rework
- Confidence score (0–10): 8

Summary

- The current script hides YAML and extractor failures, lacks logging/verbosity, and omits a self-test. The 5 diffs above add logging, error visibility, loader diagnostics, a self-test gate, a verbosity/strict toggle, sanity checks, and a heartbeat summary, aligning with the earlier Phase A/B findings and resolving the remaining blocker (self-test not invoked).
